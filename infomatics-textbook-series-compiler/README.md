# 情報系教科書シリーズ コンパイラ (オーム社)

## 1 コンパイラの概要

## 2 字句解析

### 正規表現

正規表現にははっきりした定式化がある

文字列の正規表現とは、文字集合 $\Sigma$ に対して次のルールで定義される文字列である。正規表現 $r$ が与えられたとき、それがあらわす文字列の集合を $L(r)$ と表記する。

1. 空文字列 $\epsilon$ はそれ自体が正規表現であり、 $L(r) = \{\epsilon \}$ である
2. 文字 $a_i$ はそれ自体が正規表現であり、 $L(a_i)=\{a_i\}$ である
3. $r_1$ と $r_2$ が正規表現のとき、 $r_1 | r_2$ は正規表現であり、 $L(r_1 | r_2) = L(r_1) \cup L(r_2)$ である
4. $r_1$ と $r_2$ が正規表現のとき、 $r_1 \cdot r_2$ は正規表現であり、 $L(r_1 \cdot r_2) = L(r_1) \cdot L(r_2)$ (2つの文字列集合の連結)である
5. $r$ が正規表現の時、 $r^*$ は正規表現であり、 $L(r^*)=L(r)^*$ (L(r)の閉包)である

つまり、アルファベットからスタートしてOR、連結、閉包(任意回数の連結)を繰り返した文字列を簡易に表せるのが正規表現

C言語の字句要素も簡潔に正規表現で表せる

> ソースコードから一意に正規表現を抽出できなくない？優先度が必要だよね
>> そこはプログラミング言語の基本として最長一致を採用する原則で解決する
>> `in`と`int`がどちらも検出されたら`int`とみなすのが自然だよね、という話


> そして正規表現を検出するのに便利なのが有限オートマトンの考え方。OR/連結/閉包という正規表現の構成方法がオートマトンの状態遷移構造と完璧に一致しているので有限オートマトンで受理=正規表現に合致という判断ができる

### 有限オートマトン

文字集合・状態集合・状態遷移の集合の3つ組(厳密には初期状態と終了状態を加えた5つ組)からなり、状態と文字を与えられたときに新しい状態へ遷移するような仮想計算機を有限オートマトンという

特に、状態と文字を与えられたときに状態遷移が唯一に定まる決定的なものを決定性有限オートマトン(DFA)と呼ぶ。

(非決定性は複数の経路をとりうる確率的な存在だが、字句解析の文脈では用がない)

正規表現は以下の過程を経て状態数最小のDFAに変換することができる

- 正規表現 -> 等価なNFA
- NFA -> 等価なDFA
- DFA -> 状態数最小のDFAへ変換

### 正規表現だけでは字句解析はできない。工学的な解決策

現実のプログラミング言語では以下の規則で解釈の多義性を排除する

1. 最も長い字句要素を切り出す。`in`と`int`に合致したなら`int`を採用する
2. 字句要素の種類ごとに優先順位を設ける。基本的に予約語は識別子より優先順位高く解析される

### 正規表現の限界

正規表現で表現できない例:

$X = \{a^icb^i | i \geq 0\}$ (左右に等しい数だけaとbが連結したc)

理由としては、Xを現す正規表現がもし存在すれば、それと等価なDFAはX以外の文字列も受理してしまうことになるというもの

正規表現で表せる文字列集合のクラスはかなり限定されたものであることがわかる。だからこそ字句解析というシンプルなファーストステップにのみ用いられ、プログラミング言語の複雑な論理構造にはもっと複雑なクラスを用いることになる。それが構文解析(パース)における文脈自由文法だったりする

